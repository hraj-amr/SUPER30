import Student from "../models/student.models.js";
import Counter from "../models/counter.models.js";
import { updateSheetWithAllStudents, updateSheetWithStreamSeparation } from "../utils/googleSheets.js";

export const generateRollNumbers = async (req, res) => {
  try {
    // New behavior: always generate roll numbers based on stream.
    // Each stream (PCM and PCB) will have roll numbers starting at 1.
    // Admin may choose ordering within each stream via `order` ("alphabetical" or "random").
    const order = req.body.order || "alphabetical";

    // Reset all roll numbers
    await Student.updateMany({}, { rollNo: null });

    const fetchByStream = async (stream) => {
      if (order === "random") {
        const total = await Student.countDocuments({ stream });
        if (total === 0) return [];
        return await Student.aggregate([{ $match: { stream } }, { $sample: { size: total } }]);
      }

      // alphabetical by studentName
      return await Student.find({ stream }).sort({ studentName: 1 });
    };

    const pcm = await fetchByStream("PCM");
    const pcb = await fetchByStream("PCB");

    // Assign roll numbers starting from 1 for each stream separately
    let roll = 1;
    for (const student of pcm) {
      await Student.updateOne({ _id: student._id }, { rollNo: roll });
      roll++;
    }

    roll = 1;
    for (const student of pcb) {
      await Student.updateOne({ _id: student._id }, { rollNo: roll });
      roll++;
    }

    // Update Google Sheet with PCM block, three blank rows, then PCB
    if (typeof updateSheetWithStreamSeparation === "function") {
      await updateSheetWithStreamSeparation();
    }

    return res.json({ success: true, message: `Roll numbers generated by stream (PCM & PCB) using order: ${order}.` });
  } catch (error) {
    console.error("Error generating roll numbers:", error);
    res.status(500).json({ error: "Failed to generate roll numbers" });
  }
};


// delete all students from database
export const deleteAllStudents = async (req, res) => {
  try {
    await Student.deleteMany({}); // deletes all student records
    await Counter.findOneAndUpdate(
      { id: "studentId" },
      { seq: 0 }, // reset student ID counter
      { new: true }
    );

    res.status(200).json({ message: "All student data cleared successfully" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};


// dashboard stats
export const getDashboardStats = async (req, res) => {
  try {
    const groupBy = async (field) => {
      const data = await Student.aggregate([
        { $group: { _id: `$${field}`, count: { $sum: 1 } } },
      ]);
      return data.map((d) => ({ name: d._id || "N/A", count: d.count }));
    };

    const stats = {
      gender: await groupBy("gender"),
      stream: await groupBy("stream"),
      target: await groupBy("target"),
      classMoving: await groupBy("classMoving"),
      testCentre: await groupBy("testCentre"),
      scholarship: await groupBy("scholarshipOffered"),
    };

    res.status(200).json(stats);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

export const getSummaryStats = async (req, res) => {
  try {
    const totalStudents = await Student.countDocuments();
    const pcmCount = await Student.countDocuments({ stream: "PCM" });
    const pcbCount = await Student.countDocuments({ stream: "PCB" });
    const admitCardGenerated = await Student.countDocuments({ admitCardGenerated: true });

    res.status(200).json({
      totalStudents,
      pcmCount,
      pcbCount,
      admitCardGenerated,
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};