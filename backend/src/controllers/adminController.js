import Student from "../models/student.models.js";
import Counter from "../models/counter.models.js";
import Settings from "../models/settings.models.js";
import { updateSheetWithAllStudents, updateSheetWithStreamSeparation } from "../utils/googleSheets.js";

export const generateRollNumbers = async (req, res) => {
  try {
    const order = req.body.order || "alphabetical";

    // Reset all roll numbers
    await Student.updateMany({}, { rollNo: null });

    const fetchByStream = async (stream) => {
      if (order === "random") {
        const total = await Student.countDocuments({ stream });
        if (total === 0) return [];
        return await Student.aggregate([{ $match: { stream } }, { $sample: { size: total } }]);
      }
      return await Student.find({ stream }).sort({ studentName: 1 });
    };

    const pcm = await fetchByStream("PCM");
    const pcb = await fetchByStream("PCB");

    // Prepare bulk operations for better performance
    const bulkOps = [];

    // Assign starting roll numbers for PCM stream
    let roll = 3001;
    for (const student of pcm) {
      bulkOps.push({
        updateOne: {
          filter: { _id: student._id },
          update: { $set: { rollNo: roll } }
        }
      });
      roll++;
    }

    // Assign starting roll numbers for PCB stream
    roll = 5001;
    for (const student of pcb) {
      bulkOps.push({
        updateOne: {
          filter: { _id: student._id },
          update: { $set: { rollNo: roll } }
        }
      });
      roll++;
    }

    // Execute all updates in a single operation
    if (bulkOps.length > 0) {
      await Student.bulkWrite(bulkOps);
    }

    if (typeof updateSheetWithStreamSeparation === "function") {
      await updateSheetWithStreamSeparation();
    }

    return res.json({ 
      success: true, 
      message: `Roll numbers generated by stream using order: ${order}.`,
      counts: { PCM: pcm.length, PCB: pcb.length }
    });
  } catch (error) {
    console.error("Error generating roll numbers:", error);
    res.status(500).json({ error: "Failed to generate roll numbers" });
  }
};


// delete all students from database
export const deleteAllStudents = async (req, res) => {
  try {
    await Student.deleteMany({}); // deletes all student records
    await Counter.findOneAndUpdate(
      { id: "studentId" },
      { seq: 0 }, // reset student ID counter
      { new: true }
    );

    res.status(200).json({ message: "All student data cleared successfully" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};


// dashboard stats
export const getDashboardStats = async (req, res) => {
  try {
    const groupBy = async (field) => {
      const data = await Student.aggregate([
        { $group: { _id: `$${field}`, count: { $sum: 1 } } },
      ]);
      return data.map((d) => ({ name: d._id || "N/A", count: d.count }));
    };

    const stats = {
      gender: await groupBy("gender"),
      stream: await groupBy("stream"),
      target: await groupBy("target"),
      classMoving: await groupBy("classMoving"),
      testCentre: await groupBy("testCentre"),
      scholarship: await groupBy("scholarshipOffered"),
    };

    res.status(200).json(stats);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

export const getSummaryStats = async (req, res) => {
  try {
    const totalStudents = await Student.countDocuments();
    const pcmCount = await Student.countDocuments({ stream: "PCM" });
    const pcbCount = await Student.countDocuments({ stream: "PCB" });
    const admitCardGenerated = await Student.countDocuments({ admitCardGenerated: true });

    res.status(200).json({
      totalStudents,
      pcmCount,
      pcbCount,
      admitCardGenerated,
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};




// Get current exam date
export const getExamSettings = async (req, res) => {
  try {
    let settings = await Settings.findOne();
    if (!settings) {
      settings = await Settings.create({
        examDate: "",
        lastDateToRegister: "",
        resultDate: "",
        registrationOpen: true
      });
    }
    res.status(200).json(settings);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};


// Update exam date
export const updateExamSettings = async (req, res) => {
  try {
    const { examDate, lastDateToRegister, resultDate, registrationOpen } = req.body;

    // Find existing settings first
    let settings = await Settings.findOne();
    
    // Build update object with only provided fields
    const updateData = {};
    if (examDate !== undefined) updateData.examDate = examDate;
    if (lastDateToRegister !== undefined) updateData.lastDateToRegister = lastDateToRegister;
    if (resultDate !== undefined) updateData.resultDate = resultDate;
    if (registrationOpen !== undefined) updateData.registrationOpen = registrationOpen;

    const updated = await Settings.findOneAndUpdate(
      {},
      updateData,
      { new: true, upsert: true }
    );

    res.status(200).json({
      success: true,
      message: "Exam settings updated successfully",
      settings: updated,
    });
  } catch (error) {
    console.error("Error updating exam settings:", error);
    res.status(500).json({ message: error.message });
  }
};


